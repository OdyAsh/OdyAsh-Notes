/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/.pnpm/deepmerge@4.3.1/node_modules/deepmerge/dist/cjs.js
var require_cjs = __commonJS({
  "node_modules/.pnpm/deepmerge@4.3.1/node_modules/deepmerge/dist/cjs.js"(exports, module2) {
    "use strict";
    var isMergeableObject = function isMergeableObject2(value) {
      return isNonNullObject(value) && !isSpecial(value);
    };
    function isNonNullObject(value) {
      return !!value && typeof value === "object";
    }
    function isSpecial(value) {
      var stringValue = Object.prototype.toString.call(value);
      return stringValue === "[object RegExp]" || stringValue === "[object Date]" || isReactElement(value);
    }
    var canUseSymbol = typeof Symbol === "function" && Symbol.for;
    var REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for("react.element") : 60103;
    function isReactElement(value) {
      return value.$$typeof === REACT_ELEMENT_TYPE;
    }
    function emptyTarget(val) {
      return Array.isArray(val) ? [] : {};
    }
    function cloneUnlessOtherwiseSpecified(value, options) {
      return options.clone !== false && options.isMergeableObject(value) ? deepmerge2(emptyTarget(value), value, options) : value;
    }
    function defaultArrayMerge(target, source, options) {
      return target.concat(source).map(function(element) {
        return cloneUnlessOtherwiseSpecified(element, options);
      });
    }
    function getMergeFunction(key, options) {
      if (!options.customMerge) {
        return deepmerge2;
      }
      var customMerge = options.customMerge(key);
      return typeof customMerge === "function" ? customMerge : deepmerge2;
    }
    function getEnumerableOwnPropertySymbols(target) {
      return Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(target).filter(function(symbol) {
        return Object.propertyIsEnumerable.call(target, symbol);
      }) : [];
    }
    function getKeys(target) {
      return Object.keys(target).concat(getEnumerableOwnPropertySymbols(target));
    }
    function propertyIsOnObject(object, property) {
      try {
        return property in object;
      } catch (_) {
        return false;
      }
    }
    function propertyIsUnsafe(target, key) {
      return propertyIsOnObject(target, key) && !(Object.hasOwnProperty.call(target, key) && Object.propertyIsEnumerable.call(target, key));
    }
    function mergeObject(target, source, options) {
      var destination = {};
      if (options.isMergeableObject(target)) {
        getKeys(target).forEach(function(key) {
          destination[key] = cloneUnlessOtherwiseSpecified(target[key], options);
        });
      }
      getKeys(source).forEach(function(key) {
        if (propertyIsUnsafe(target, key)) {
          return;
        }
        if (propertyIsOnObject(target, key) && options.isMergeableObject(source[key])) {
          destination[key] = getMergeFunction(key, options)(target[key], source[key], options);
        } else {
          destination[key] = cloneUnlessOtherwiseSpecified(source[key], options);
        }
      });
      return destination;
    }
    function deepmerge2(target, source, options) {
      options = options || {};
      options.arrayMerge = options.arrayMerge || defaultArrayMerge;
      options.isMergeableObject = options.isMergeableObject || isMergeableObject;
      options.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;
      var sourceIsArray = Array.isArray(source);
      var targetIsArray = Array.isArray(target);
      var sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;
      if (!sourceAndTargetTypesMatch) {
        return cloneUnlessOtherwiseSpecified(source, options);
      } else if (sourceIsArray) {
        return options.arrayMerge(target, source, options);
      } else {
        return mergeObject(target, source, options);
      }
    }
    deepmerge2.all = function deepmergeAll(array, options) {
      if (!Array.isArray(array)) {
        throw new Error("first argument should be an array");
      }
      return array.reduce(function(prev, next) {
        return deepmerge2(prev, next, options);
      }, {});
    };
    var deepmerge_1 = deepmerge2;
    module2.exports = deepmerge_1;
  }
});

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => TreeFocusPlugin
});
module.exports = __toCommonJS(main_exports);

// src/core/tree-focus.ts
var import_obsidian4 = require("obsidian");

// src/util/logger.ts
var import_obsidian2 = require("obsidian");

// src/core/plugin-info.ts
var import_obsidian = require("obsidian");

// src/core/plugin-strings.ts
var PluginStrings = class {
  static get pluginBugAppendix() {
    var _a, _b;
    return `

!!! UNEXPECTED !!!

    You discovered a bug in the plugin '${PluginInfo.manifest.name}'. I kindly ask you to report this issue on ${(_a = PluginInfo.repository.provider) != null ? _a : "NOT_SET"}.
    
    This way you & all other people can benefit from your discovery! :)
    
    
    Please include the following information in your report:
    
    	- ${PluginInfo.humanIdentifier}
    	- Obsidian @ v${PluginInfo.obsidianVersion}
    
    Link for issue reporting:
    
    	${(_b = PluginInfo.repository.issuesUrl) != null ? _b : "NOT_SET"}
    
    
    `;
  }
};

// src/util/error-helper.ts
var ErrorHelper = class {
  /**
   * Creates an error with the given message and additional information that
   * gives the user more details on the error such as that this is a plugin bug
   * and how to report it.
   * 
   * The error needs to be thrown manually.
   */
  static pluginBug(message) {
    let finalMessage = message;
    try {
      finalMessage += PluginStrings.pluginBugAppendix;
    } catch (e) {
      Log.error("Failed to append bug appendix to error message.", e);
    }
    return new Error(finalMessage);
  }
};

// src/core/plugin-info.ts
var PluginInfo = class {
  static get obsidianVersion() {
    if (!this._obsidianVersion) {
      throw ErrorHelper.pluginBug("Trying to access Obsidian version before it was set.");
    }
    return this._obsidianVersion;
  }
  static get manifest() {
    if (!this._manifest) {
      throw ErrorHelper.pluginBug("Trying to access manifest before it was set.");
    }
    return this._manifest;
  }
  static get humanIdentifier() {
    return `${this.manifest.name} (${this.manifest.id} @ v${this.manifest.version})`;
  }
  static get pluginId() {
    return this.manifest.id;
  }
  static get pluginName() {
    return this.manifest.name;
  }
  static _internalInit(app, manifest) {
    if (this._manifest || this._obsidianVersion) {
      throw ErrorHelper.pluginBug("Trying to set plugin info twice.");
    }
    this._obsidianVersion = import_obsidian.apiVersion;
    this._manifest = manifest;
  }
};
PluginInfo.repository = {
  type: "git",
  provider: "GitHub",
  providerUrl: "https://github.com",
  repoUrl: "https://github.com/iOSonntag/obsidian-plugin-treefocus",
  issuesUrl: "https://github.com/iOSonntag/obsidian-plugin-treefocus/issues"
};

// src/util/logger.ts
var Log = class {
  /**
     * Logs only if `Platform.isDesktopApp` and if available `process.env.NODE_ENV !== 'production'`.
     * 
     * Adds useful information to the log message and then logs it using `console.log`.
     * 
     * Info added:
     * - plugin id from {@link PluginMeta.id}
     */
  static debug(message, ...args) {
    if (import_obsidian2.Platform.isDesktopApp) {
      if (true) {
        console.log(`[DEBUG][${PluginInfo.pluginId}]: ${message}`, ...args);
      }
    }
  }
  /**
   * Adds useful information to the log message and then logs it using `console.log`.
   * 
   * Info added:
   * - plugin id from {@link PluginInfo.pluginId}
   */
  static log(message, ...args) {
    console.log(`[INFO] [${PluginInfo.pluginId}]: ${message}`, ...args);
  }
  /**
   * Adds useful information to the warning and then logs it using `console.warn`.
   * 
   * Info added:
   * - plugin id from {@link PluginInfo.pluginId}
   */
  static warn(message, ...args) {
    console.warn(`[WARN] [${PluginInfo.pluginId}]: ${message}`, ...args);
  }
  /**
   * Adds useful information to the error message and then logs it using `console.error`.
   * 
   * Info added:
   * - plugin id from {@link PluginInfo.pluginId}
   */
  static error(message, ...args) {
    console.error(`[ERROR][${PluginInfo.pluginId}]: ${message}`, ...args);
  }
  /**
   * Use this logger to log triggered/called events.
   * 
   * Info added:
   * - plugin id from {@link PluginInfo.pluginId}
   * - event name
   */
  static eventFired(event, ...args) {
    console.log(`[EVENT][${PluginInfo.pluginId}]: ${event}`, ...args);
  }
};

// src/enhanced-obsidian-components/known-type-keys.ts
var VIEW_TYPE_FILE_EXPLORER = "file-explorer";
var SOURCE_TYPE_FILE_EXPLORER_CONTEXT_MENU = "file-explorer-context-menu";

// src/core/plugin-bundle.ts
var Bundle = class {
  static _internalInit(app, plugin, manifest) {
    this._app = new WeakRef(app);
    this._plugin = new WeakRef(plugin);
    this._manifest = new WeakRef(manifest);
  }
  static get app() {
    var _a;
    let app = (_a = this._app) == null ? void 0 : _a.deref();
    if (!app) {
      throw ErrorHelper.pluginBug("App is not initialized or already garbage collected.");
    }
    return app;
  }
  static get plugin() {
    var _a;
    let plugin = (_a = this._plugin) == null ? void 0 : _a.deref();
    if (!plugin) {
      throw ErrorHelper.pluginBug("Plugin is not initialized or already garbage collected.");
    }
    return plugin;
  }
  static get manifest() {
    var _a;
    let manifest = (_a = this._manifest) == null ? void 0 : _a.deref();
    if (!manifest) {
      throw ErrorHelper.pluginBug("Manifest is not initialized or already garbage collected.");
    }
    return manifest;
  }
};

// src/services/plugin-data-store.ts
var import_deepmerge = __toESM(require_cjs());
var PluginDataStore = class {
  /**
   * Initializes the data store by loading the data from the file system and
   * storing it in memory.
   * 
   * If `defaultData` is provided, it will be deeply merged with the data from
   * the file system. The data from the file system will overwrite the default
   * data.
   */
  static async init(defaultData) {
    Log.log("loading plugin data store");
    Log.debug("default data", defaultData);
    let storedData = await Bundle.plugin.loadData();
    defaultData = defaultData ? defaultData : {};
    this._data = storedData ? storedData : defaultData;
    Log.debug("done loading plugin data store", this._data);
  }
  /**
   * Returns `true` if the data store is fully initialized.
   * 
   * Basically that means that the data is read from the file system and stored
   * in memory. 
   */
  static get initialized() {
    return !!this._data;
  }
  /**
   * Stores the given data in the data store and saves it to the file system.
   * 
   * Optionally pass `merge = true` to deeply merge the data with any existing
   * data (if existent).
   */
  static async set(key, data, merge = false) {
    Log.debug("storing data", key, data);
    Log.debug("merge", merge);
    if (!this._data) {
      throw ErrorHelper.pluginBug("Data store is not initialized.");
    }
    if (merge && this._data[key]) {
      data = data ? (0, import_deepmerge.default)(this._data[key], data) : this._data[key];
      Log.debug("merged data", data);
    }
    this._data[key] = data;
    await Bundle.plugin.saveData(this._data);
  }
  /**
   * Stores the given data in the data store and saves it to the file system.
   * 
   * Optionally pass `merge = true` to deeply merge the data with any existing
   * data (if existent).
   */
  static async setAll(data, merge = false) {
    Log.debug("storing all data", data);
    Log.debug("merge", merge);
    if (!this._data) {
      throw ErrorHelper.pluginBug("Data store is not initialized.");
    }
    if (merge) {
      data = data ? (0, import_deepmerge.default)(this._data, data) : this._data;
      Log.debug("merged data", data);
    }
    this._data = data;
    await Bundle.plugin.saveData(this._data);
  }
  /**
   * Returns the data stored under the given key.
   */
  static get(key) {
    Log.debug("get value from data store", key);
    if (!this._data) {
      throw ErrorHelper.pluginBug("Data store is not initialized.");
    }
    let data = this._data[key];
    Log.debug("got data", data);
    return data;
  }
  /**
   * Returns the data stored under the given key. The data is expected to be a
   * string. If it is not a string or empty, an error is thrown.
   * 
   * Use {@link PluginDataStore.get} if you want to get any data type or expect empty data.
   */
  static getStringOrThrow(key) {
    Log.debug("get string from data store", key);
    let value = this.get(key);
    if (typeof value !== "string" || value === "") {
      throw ErrorHelper.pluginBug(`Value for key '${key}' is not a string or empty.`);
    }
    Log.debug("got string", value);
    return value;
  }
  /**
   * Returns all data of the data store.
   */
  static getAll() {
    Log.debug("get all data from data store");
    if (!this._data) {
      throw ErrorHelper.pluginBug("Data store is not initialized.");
    }
    return this._data;
  }
};

// src/_config/initial-settings.ts
var DEFAULT_RULES = () => [
  {
    matcher: {
      method: "STARTS_WITH",
      value: "_",
      context: "NAME"
    },
    mode: "DIM",
    excludes: []
  },
  {
    matcher: {
      method: "STARTS_WITH",
      value: ".",
      context: "NAME"
    },
    mode: "DIM",
    excludes: []
  },
  {
    matcher: {
      method: "STARTS_WITH",
      value: "!",
      context: "NAME"
    },
    mode: "HIGHLIGHT",
    excludes: []
  }
];
var initialSettings = {
  transformPreset: "DEFAULT",
  rules: DEFAULT_RULES(),
  fileOverwrites: {}
};

// src/enhanced-obsidian-components/obsidian-settings-tab.ts
var import_obsidian3 = require("obsidian");
var ObsidianSettingsTab = class extends import_obsidian3.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
  }
  /**
   * Do not override this method. Override {@link build} instead.
   */
  display() {
    const rootElement = this.containerEl;
    rootElement.empty();
    const context = {
      rootElement,
      createSetting: () => new import_obsidian3.Setting(rootElement),
      createSectionHeader: (title, description) => {
        rootElement.createEl("h3", { text: title });
        if (description) {
          rootElement.createDiv({ cls: "setting-section-description", text: description });
        }
      },
      createSectionDivider: () => rootElement.createDiv({ cls: "setting-section-divider" }),
      createSupportLinks: (buyMeACoffeeUsername, payPalUrl) => {
        if (buyMeACoffeeUsername) {
          rootElement.createEl("br");
          const parentEl = rootElement.createEl("a", {
            href: `https://www.buymeacoffee.com/${buyMeACoffeeUsername}`
          });
          parentEl.createEl("img", {
            attr: {
              src: "https://cdn.buymeacoffee.com/buttons/v2/default-yellow.png",
              alt: "Buy Me A Coffee",
              style: "height: 60px !important;width: 217px !important;"
            }
          });
          rootElement.createEl("br");
        }
        if (payPalUrl) {
          rootElement.createEl("br");
          const parentEl = rootElement.createEl("a", {
            href: payPalUrl
          });
          parentEl.createEl("img", {
            attr: {
              src: "https://www.paypalobjects.com/webstatic/de_DE/i/de-pp-logo-200px.png",
              alt: "Donate with PayPal",
              style: "height: 60px !important;width: 217px !important;"
            }
          });
          rootElement.createEl("br");
        }
      },
      applySettings: () => {
        this.display();
        this.didUpdateSettings();
      }
    };
    this.build(context);
  }
};

// src/core/plugin-settings.ts
var PluginSettings = class {
  /**
   * Returns the entire settings object. 
   **/
  static getAll() {
    return PluginDataStore.getAll();
  }
  /**
   * Returns a setting value by key.
   */
  static get(key) {
    return PluginDataStore.get(key);
  }
  /**
   * Sets a setting value by key.
   */
  static async set(key, value) {
    await PluginDataStore.set(key, value);
  }
  /**
   * Returns the configured matching rules, sorted by priority.
   */
  static getMatchingRules() {
    return PluginSettings.get("rules");
  }
  /**
   * Resets the matching rules to the default rules.
   */
  static async resetMatchingRules() {
    await PluginSettings.set("rules", DEFAULT_RULES());
  }
  /**
   * Returns the explicit {@link ItemFocusMode} set for the given file path if any.
   */
  static getExplicitMode(path) {
    const files = PluginSettings.get("fileOverwrites");
    return files[path];
  }
  /**
   * Returns all file paths that have an explicit {@link ItemFocusMode} set.
   */
  static getExplicitModePaths() {
    const files = PluginSettings.get("fileOverwrites");
    return Object.keys(files);
  }
  /**
   * Sets the explicit {@link ItemFocusMode} for the given file path.
   */
  static async setExplicitMode(path, mode) {
    const files = PluginSettings.get("fileOverwrites");
    files[path] = mode;
    await PluginSettings.set("fileOverwrites", files);
  }
  /**
   * Removes the explicit {@link ItemFocusMode} for the given file path.
   */
  static async removeExplicitMode(path) {
    const files = PluginSettings.get("fileOverwrites");
    delete files[path];
    await PluginSettings.set("fileOverwrites", files);
  }
};

// src/util/rules-helper.ts
var RulesHelper = class {
  static createRule() {
    return {
      matcher: {
        method: "STARTS_WITH",
        value: "",
        context: "NAME"
      },
      mode: "DEFAULT",
      excludes: []
    };
  }
  static ruleIsValid(rule) {
    return rule.matcher.value.length > 0;
  }
};

// src/views/settings-view.ts
var presetOptions = {
  "DEFAULT": "Default",
  "FANCY": "Fancy",
  "DELIGHT": "Delight"
};
var matcherMethodOptions = {
  "EQUALS": "equals",
  "STARTS_WITH": "starts with",
  "ENDS_WITH": "ends with",
  "CONTAINS": "contains",
  "REGEX": "matches regex"
};
var focusModeOptions = {
  "DIM": "Dim",
  "HIGHLIGHT": "Highlight"
  // 'HIDE': 'Hide',
};
var matchContextOptions = {
  "NAME": "if name",
  "PATH": "if path"
};
var SettingsView = class extends ObsidianSettingsTab {
  constructor(onUpdateSettings) {
    super(Bundle.app, Bundle.plugin);
    this.onUpdateSettings = onUpdateSettings;
  }
  didUpdateSettings() {
    Log.debug("didUpdateSettings");
    this.onUpdateSettings();
  }
  build(context) {
    context.createSectionHeader("Transformation style");
    context.createSetting().setName("Preset").setDesc("Controls the style of the applied rules. More presets might be added in the future.").addDropdown((dropdown) => dropdown.addOptions(presetOptions).setValue(PluginSettings.get("transformPreset")).onChange(async (value) => {
      await PluginSettings.set("transformPreset", value);
      context.applySettings();
    }));
    context.createSectionDivider();
    context.createSectionHeader("Transformation rules", "Define a set of rules that transform items (files and folders) in the file explorer.\n\nRules are checked in the order they are defined. The first rule that matches an item will be applied.\nIf an item has an explicit transformation set, rules are disabled for that item.");
    context.createSetting().setHeading().setName("Rules").addButton((button) => button.setCta().setButtonText("Reset to defaults").onClick(async () => {
      await PluginSettings.resetMatchingRules();
      context.applySettings();
    })).addButton((button) => button.setButtonText("Add rule").onClick(async () => {
      const rule = RulesHelper.createRule();
      const rules2 = PluginSettings.get("rules");
      rules2.push(rule);
      await PluginSettings.set("rules", rules2);
      context.applySettings();
    }));
    const rules = PluginSettings.get("rules");
    for (let i = 0; i < rules.length; i++) {
      this.createRule(context, rules, i);
    }
    context.createSectionDivider();
    context.createSectionHeader("Explicit transformations", 'Items with explicit transformation configuration. To add an item, right click it in the file explorer and select an option below "TreeFocus".');
    const fileOverwrites = PluginSettings.get("fileOverwrites");
    const keys = Object.keys(fileOverwrites).sort();
    for (let i = 0; i < keys.length; i++) {
      const key = keys[i];
      this.createFileOverwrite(context, fileOverwrites, key);
    }
    context.createSectionDivider();
    context.createSectionHeader("Support this plugin", "If you like this plugin and want to support it - submit a feature request, a pull request or simply buy me a little coffee :) - Thank You.");
    context.createSupportLinks("iOSonntag", "https://paypal.com/paypalme/iOSonntag/20");
  }
  createRule(context, rules, index) {
    const rule = rules[index];
    if (!rule)
      return;
    const setting = context.createSetting().setName(`#${index + 1}`).addDropdown(
      (dropdown) => dropdown.addOptions(focusModeOptions).setValue(rule.mode).onChange(async (value) => {
        rule.mode = value;
        await PluginSettings.set("rules", rules);
        context.applySettings();
      })
    ).addDropdown(
      (dropdown) => dropdown.addOptions(matchContextOptions).setValue(rule.matcher.context).onChange(
        async (value) => {
          rule.matcher.context = value;
          await PluginSettings.set("rules", rules);
          context.applySettings();
        }
      )
    ).addDropdown(
      (dropdown) => dropdown.addOptions(matcherMethodOptions).setValue(rule.matcher.method).onChange(
        async (value) => {
          rule.matcher.method = value;
          await PluginSettings.set("rules", rules);
          context.applySettings();
        }
      )
    ).addText(
      (text) => text.setPlaceholder("Enter a value...").setValue(rule.matcher.value).onChange(async (value) => {
        rule.matcher.value = value;
        await PluginSettings.set("rules", rules);
        context.applySettings();
      })
    );
    setting.addExtraButton(
      (button) => button.setIcon("chevron-up").setTooltip("Move rule up").setDisabled(index === 0).onClick(async () => {
        const temp = rules[index - 1];
        rules[index - 1] = rule;
        rules[index] = temp;
        await PluginSettings.set("rules", rules);
        context.applySettings();
      })
    ).addExtraButton(
      (button) => button.setIcon("chevron-down").setTooltip("Move rule down").setDisabled(index === rules.length - 1).onClick(async () => {
        const temp = rules[index + 1];
        rules[index + 1] = rule;
        rules[index] = temp;
        await PluginSettings.set("rules", rules);
        context.applySettings();
      })
    ).addExtraButton(
      (button) => button.setIcon("trash").setTooltip("Delete Rule").onClick(async () => {
        rules.splice(index, 1);
        await PluginSettings.set("rules", rules);
        context.applySettings();
      })
    );
  }
  createFileOverwrite(context, fileOverwrites, key) {
    const rule = fileOverwrites[key];
    if (!rule) {
      return;
    }
    context.createSetting().setName(key).setDesc(rule).addExtraButton(
      (button) => button.setIcon("trash").setTooltip("Remove explicit transformation").onClick(async () => {
        delete fileOverwrites[key];
        await PluginSettings.set("fileOverwrites", fileOverwrites);
        context.applySettings();
      })
    );
  }
};

// src/util/file-explorer-helper.ts
var FileExplorerHelper = class {
  /**
   * Iterates over every item in the given file explorer and calls the callback with the path and the item.
   */
  static forEveryItem(fileExplorer, callback) {
    if (!fileExplorer.ready) {
      Log.warn("accessing a file explorer that is not ready yet (might be critical)", fileExplorer);
    }
    let paths = fileExplorer.fileItems ? Object.keys(fileExplorer.fileItems) : [];
    Log.debug("do for every file explorer item - count", paths.length);
    for (let fiPath of paths) {
      let item = fileExplorer.fileItems[fiPath];
      callback(fiPath, item);
    }
  }
};

// src/util/css-tool.ts
var CssTool = class {
  /**
   * Applies the given styles to multiple html elements using Obsidians own
   * implementation ({@link HTMLElement.setCssStyles}).
   */
  static applyStylesToMany(htmlElements, styles) {
    for (let htmlElement of htmlElements) {
      this.applyStyles(htmlElement, styles);
    }
  }
  /**
   * Applies the given styles to the given html element using Obsidians own
   * implementation ({@link HTMLElement.setCssStyles}).
   */
  static applyStyles(htmlElement, styles) {
    htmlElement.setCssStyles(styles);
  }
  /**
   * Applies a data attribute to the given html element. 
   * 
   * **Note** 
   * - the key should be camel cased because it will be converted to kebab case
   *   automatically. 
   * - the key will be prefixed with `data-` automatically. 
   * 
   * Example:
   * ```ts
   * CssTool.applyDataAttribute(htmlElement, 'myAttribute', 'SOME_VALUE');
   * ```
   * Results in:
   * ```html
   * <div data-my-attribute="SOME_VALUE"></div>
   * ```
   */
  static applyDataAttribute(htmlElement, key, value) {
    htmlElement.dataset[key] = value;
  }
  /**
   * Removes a data attribute from the given html element.
   * 
   * **Note**
   * - the key should be camel cased because it will be converted to kebab case
   *   automatically.
   * - the key will be prefixed with `data-` automatically.
   * 
   * Example:
   * ```ts
   * CssTool.removeDataAttribute(htmlElement, 'myAttribute');
   * ```
   * When having this html element:
   * ```html
   * <div data-my-attribute="SOME_VALUE"></div>
   * ```
   */
  static removeDataAttribute(htmlElement, key) {
    delete htmlElement.dataset[key];
  }
};

// src/services/mode-evaluation-service.ts
var ModeEvaluationService = class {
  /**
   * Evaluates the mode for the given path and name of a file or folder.
   * 
   * Explicit mode is prioritized over rules.
   * 
   * If no explicit mode is set, the rules are evaluated in order of their
   * appearance in the settings. 
   * The first rule that matches the path or name of the file or folder is used.
   */
  static evaluateMode(path, name) {
    const explicitMode = PluginSettings.getExplicitMode(path);
    if (explicitMode) {
      Log.debug("explicit mode", explicitMode);
      return explicitMode;
    }
    for (const fiMatchingRule of PluginSettings.getMatchingRules()) {
      if (RulesHelper.ruleIsValid(fiMatchingRule) === false) {
        continue;
      }
      if (this.matchesRule(path, name, fiMatchingRule)) {
        Log.debug("item matched rule");
        Log.debug("path:", path);
        Log.debug("mode:", fiMatchingRule.mode);
        return fiMatchingRule.mode;
      }
    }
    return "DEFAULT";
  }
  static matchesRule(path, name, rule) {
    const matcher = rule.matcher;
    const value = matcher.context === "NAME" ? name : path;
    switch (matcher.method) {
      case "EQUALS":
        return this.matchesEquals(value, matcher);
      case "CONTAINS":
        return this.matchesContains(value, matcher);
      case "STARTS_WITH":
        return this.matchesStartsWith(value, matcher);
      case "ENDS_WITH":
        return this.matchesEndsWith(value, matcher);
      case "REGEX":
        return this.matchesRegex(value, matcher);
      default:
        return false;
    }
  }
  static matchesEquals(value, matcher) {
    return value === matcher.value;
  }
  static matchesContains(value, matcher) {
    return value.includes(matcher.value);
  }
  static matchesStartsWith(value, matcher) {
    return value.startsWith(matcher.value);
  }
  static matchesEndsWith(value, matcher) {
    return value.endsWith(matcher.value);
  }
  static matchesRegex(value, matcher) {
    const regex = new RegExp(matcher.value);
    return regex.test(value);
  }
};

// src/core/tree-focus.ts
var TreeFocus = class {
  getSettingsView() {
    if (!this.settingsView) {
      throw ErrorHelper.pluginBug("settingsView is not set");
    }
    return this.settingsView;
  }
  constructor(app, plugin, manifest) {
    this.app = app;
    this.plugin = plugin;
    this.manifest = manifest;
  }
  async init() {
    Log.log("initializing core");
    this.refreshDebouncer = (0, import_obsidian4.debounce)(
      () => this.refresh(),
      50,
      true
    );
    await PluginDataStore.init(initialSettings);
    this.settingsView = new SettingsView(() => this.onSettingsChanged());
  }
  onOpenFileExplorerContextMenu(menu, file) {
    Log.debug("open file explorer context menu", menu, file);
    menu.addSeparator();
    const explicitMode = PluginSettings.getExplicitMode(file.path);
    const itemHeadline = (item) => {
      item.setTitle("TreeFocus");
      item.setDisabled(true);
    };
    const highlighted = explicitMode === "HIGHLIGHT";
    const itemHighlight = (item) => {
      item.setTitle("Highlight");
      item.setChecked(highlighted);
      item.onClick(async () => {
        if (highlighted) {
          await PluginSettings.removeExplicitMode(file.path);
        } else {
          await PluginSettings.setExplicitMode(file.path, "HIGHLIGHT");
        }
        this.requestRefresh();
      });
    };
    const dimmed = explicitMode === "DIM";
    const itemDim = (item) => {
      item.setTitle("Dim");
      item.setChecked(dimmed);
      item.onClick(async () => {
        if (dimmed) {
          await PluginSettings.removeExplicitMode(file.path);
        } else {
          await PluginSettings.setExplicitMode(file.path, "DIM");
        }
        this.requestRefresh();
      });
    };
    const explicitDefault = explicitMode === "DEFAULT";
    const itemExplicitDefault = (item) => {
      item.setTitle("Default (rule overwrite)");
      item.setChecked(explicitDefault);
      item.onClick(async () => {
        if (explicitDefault) {
          await PluginSettings.removeExplicitMode(file.path);
        } else {
          await PluginSettings.setExplicitMode(file.path, "DEFAULT");
        }
        this.requestRefresh();
      });
    };
    const itemReset = (item) => {
      item.setTitle("Reset...");
      item.setDisabled(explicitMode === void 0);
      item.onClick(async () => {
        await PluginSettings.removeExplicitMode(file.path);
        this.requestRefresh();
      });
    };
    menu.addItem(itemHeadline);
    menu.addItem(itemHighlight);
    menu.addItem(itemDim);
    menu.addItem(itemExplicitDefault);
    menu.addItem(itemReset);
  }
  /**
   * Use this method to request the first run of changes made to obsidian by the
   * tree focus plugin.
   */
  requestInitialRefresh() {
    Log.log("initial refresh requested");
    setTimeout(() => {
      this.performPluginCleanupTask();
    }, 500);
    this.requestRefresh();
  }
  /**
   * Use this method to clean the plugin. Currently this method does the
   * following:
   * 
   * - checks for orphaned explicit file modes stored and removes them.
   */
  async performPluginCleanupTask() {
    const allItemPaths = [];
    let fileExplorers = this.getFileExplorers();
    for (let fiExplorer of fileExplorers) {
      FileExplorerHelper.forEveryItem(fiExplorer, (path, item) => {
        allItemPaths.push(path);
      });
    }
    const availableExplicitPaths = [...PluginSettings.getExplicitModePaths()];
    const orphanedExplicitPaths = availableExplicitPaths.filter((path) => allItemPaths.includes(path) === false);
    Log.debug("orphaned explicit paths", orphanedExplicitPaths);
    for (const orphanedPath of orphanedExplicitPaths) {
      await PluginSettings.removeExplicitMode(orphanedPath);
    }
  }
  /**
   * Use this method to request a refresh of the changes made to obsidian by the
   * tree focus plugin.
   */
  requestRefresh() {
    Log.log("refresh requested");
    if (!this.refreshDebouncer) {
      throw ErrorHelper.pluginBug("refreshDebouncer is not set");
    }
    this.refreshDebouncer();
  }
  /**
   * Fired when a file has been renamed / moved.
   */
  onFileMoved(newPath, oldPath) {
    Log.debug("file moved", "newPath", newPath, "oldPath", oldPath);
    const explicitMode = PluginSettings.getExplicitMode(oldPath);
    if (explicitMode) {
      PluginSettings.setExplicitMode(newPath, explicitMode);
      PluginSettings.removeExplicitMode(oldPath);
    }
    this.requestRefresh();
  }
  /**
  * Fired when a file has been deleted.
  */
  onFileDeleted(path) {
    Log.debug("file deleted", path);
    const explicitMode = PluginSettings.getExplicitMode(path);
    if (explicitMode) {
      PluginSettings.removeExplicitMode(path);
    }
    this.requestRefresh();
  }
  /**
   * Fired when the settings of the plugin have been changed.
   */
  onSettingsChanged() {
    Log.log("settings changed");
    this.requestRefresh();
  }
  /**
   * Refreshes the changes made to obsidian by the tree focus plugin.
   */
  refresh() {
    Log.log("refreshing");
    this.removeElementChanges();
    this.addElementChanges();
  }
  /**
   * Removes all changes made to obsidian by the tree focus plugin.
   */
  removeElementChanges() {
    Log.log("removing element changes");
    let fileExplorers = this.getFileExplorers();
    for (let fiExplorer of fileExplorers) {
      FileExplorerHelper.forEveryItem(fiExplorer, (path, item) => {
        CssTool.removeDataAttribute(item.selfEl, "treefocusTheme");
        CssTool.removeDataAttribute(item.selfEl, "treefocusMode");
      });
    }
  }
  /**
   * Adds all obsidian modifications by the tree focus plugin.
   */
  addElementChanges() {
    Log.log("adding element changes");
    let fileExplorers = this.getFileExplorers();
    const transformPreset = PluginSettings.get("transformPreset");
    Log.debug("transform preset", transformPreset);
    for (let fiExplorer of fileExplorers) {
      FileExplorerHelper.forEveryItem(fiExplorer, (path, item) => {
        const mode = ModeEvaluationService.evaluateMode(path, item.file.name);
        if (mode === "DEFAULT") {
          return;
        }
        CssTool.applyDataAttribute(item.selfEl, "treefocusTheme", transformPreset);
        CssTool.applyDataAttribute(item.selfEl, "treefocusMode", mode);
      });
    }
  }
  /**
   * Gets all file explorers in the current workspace.
   */
  getFileExplorers() {
    Log.debug("getting file explorers");
    let list = this.app.workspace.getLeavesOfType(VIEW_TYPE_FILE_EXPLORER);
    let finalList = list.map((leaf) => {
      return leaf.view;
    });
    Log.debug("found file explorers", finalList);
    return finalList;
  }
};

// src/enhanced-obsidian-components/obsidian-plugin.ts
var import_obsidian5 = require("obsidian");
var ObsidianPlugin2 = class extends import_obsidian5.Plugin {
  constructor(app, manifest) {
    super(app, manifest);
    Bundle._internalInit(app, this, manifest);
    PluginInfo._internalInit(app, manifest);
  }
  /**
   * From Obsidian Docs:
   * 
   * *Runs whenever the user starts using the plugin in Obsidian.*  
   * *This is where you'll configure most of the plugin's capabilities.*
   * 
   * @mustCallSuper
   */
  async onload() {
    Log.log("");
    Log.log("obsidian plugin loading");
  }
  /**
   * From Obsidian Docs:
   * 
   * *Runs when the plugin is disabled.*  
   * *Any resources that your plugin is using must be released here to avoid
   * affecting the performance of Obsidian after your plugin has been disabled.* 
   * 
   * @mustCallSuper
   */
  onunload() {
    Log.log("obsidian plugin unloading");
  }
  // IMPROVE: add automatic logging of events
  // registerEvent(eventRef: EventRef): void
  // {
  //   Log.log('obsidian plugin is registering event', eventRef);
  //   super.registerEvent(eventRef);
  // }
  // eventHandled(name: string): void
  // {
  //   Log.obsidianEvent(name);
  // }
  // listenWorkspaceEvent(name: 'layout-change', callback: () => void): void
  // {
  //   Log.obsidianEvent(name);
  //   callback.bind(this);
  //   super.registerEvent(this.app.workspace.on(name, () => 
  //   {
  //     this.eventHandled(name);
  //     callback();
  //   }));
  // }
};

// main.ts
var TreeFocusPlugin = class extends ObsidianPlugin2 {
  constructor(app, manifest) {
    super(app, manifest);
    this.treeFocus = new TreeFocus(app, this, manifest);
  }
  async onload() {
    await super.onload();
    await this.treeFocus.init();
    this.app.workspace.onLayoutReady(() => this.treeFocus.requestInitialRefresh());
    this.registerEvent(this.app.workspace.on("layout-change", () => this.onObsidianEvent("workspace.layout-change")));
    this.registerEvent(this.app.workspace.on("file-menu", (menu, file, source, leaf) => this.onFileMenu(menu, file, source, leaf)));
    this.registerEvent(this.app.vault.on("create", () => this.onObsidianEvent("vault.create")));
    this.registerEvent(this.app.vault.on("rename", (file, oldPath) => this.onFileEventRename(file, oldPath)));
    this.registerEvent(this.app.vault.on("delete", (file) => this.onFileEventDelete(file)));
    this.addSettingTab(this.treeFocus.getSettingsView());
    Log.log("obsidian plugin skeleton loading complete");
  }
  getFileExplorers() {
    let list = this.app.workspace.getLeavesOfType(VIEW_TYPE_FILE_EXPLORER);
    return list.map((leaf) => leaf.view);
  }
  onFileEventRename(file, oldPath) {
    Log.eventFired("vault.rename", "file", file, "oldPath", oldPath);
    this.treeFocus.onFileMoved(file.path, oldPath);
  }
  onFileEventDelete(file) {
    Log.eventFired("vault.delete", "file", file);
    this.treeFocus.onFileDeleted(file.path);
  }
  onObsidianEvent(name) {
    Log.eventFired(name);
    this.treeFocus.requestRefresh();
  }
  onFileMenu(menu, file, source, leaf) {
    Log.eventFired("workspace.file-menu");
    Log.debug("menu", menu, "file", file, "source", source, "leaf", leaf);
    if (source !== SOURCE_TYPE_FILE_EXPLORER_CONTEXT_MENU)
      return;
    this.treeFocus.onOpenFileExplorerContextMenu(menu, file);
  }
  onunload() {
    super.onunload();
  }
  // async onloadOld()
  // {
  // 	await this.loadSettings();
  // 	// This creates an icon in the left ribbon.
  // 	const ribbonIconEl = this.addRibbonIcon('dice', 'Sample Plugin', (evt: MouseEvent) => {
  // 		// Called when the user clicks the icon.
  // 		new Notice('This is a notice!!!!');
  // 	});
  // 	// Perform additional things with the ribbon
  // 	ribbonIconEl.addClass('my-plugin-ribbon-class');
  // 	// This adds a status bar item to the bottom of the app. Does not work on mobile apps.
  // 	const statusBarItemEl = this.addStatusBarItem();
  // 	statusBarItemEl.setText('Status Bar Text');
  // 	// This adds a simple command that can be triggered anywhere
  // 	this.addCommand({
  // 		id: 'open-sample-modal-simple',
  // 		name: 'Open sample modal (simple)',
  // 		callback: () => {
  // 			new SampleModal(this.app).open();
  // 		}
  // 	});
  // 	// This adds an editor command that can perform some operation on the current editor instance
  // 	this.addCommand({
  // 		id: 'sample-editor-command',
  // 		name: 'Sample editor command',
  // 		editorCallback: (editor: Editor, view: MarkdownView) => {
  // 			console.log(editor.getSelection());
  // 			editor.replaceSelection('Sample Editor Command');
  // 		}
  // 	});
  // 	// This adds a complex command that can check whether the current state of the app allows execution of the command
  // 	this.addCommand({
  // 		id: 'open-sample-modal-complex',
  // 		name: 'Open sample modal (complex)',
  // 		checkCallback: (checking: boolean) => {
  // 			// Conditions to check
  // 			const markdownView = this.app.workspace.getActiveViewOfType(MarkdownView);
  // 			if (markdownView) {
  // 				// If checking is true, we're simply "checking" if the command can be run.
  // 				// If checking is false, then we want to actually perform the operation.
  // 				if (!checking) {
  // 					new SampleModal(this.app).open();
  // 				}
  // 				// This command will only show up in Command Palette when the check function returns true
  // 				return true;
  // 			}
  // 		}
  // 	});
  // 	// This adds a settings tab so the user can configure various aspects of the plugin
  // 	this.addSettingTab(new SampleSettingTab(this.app, this));
  // 	// If the plugin hooks up any global DOM events (on parts of the app that doesn't belong to this plugin)
  // 	// Using this function will automatically remove the event listener when this plugin is disabled.
  // 	this.registerDomEvent(document, 'click', (evt: MouseEvent) => {
  // 		console.log('click', evt);
  // 	});
  // 	// When registering intervals, this function will automatically clear the interval when the plugin is disabled.
  // 	this.registerInterval(window.setInterval(() => console.log('setInterval'), 5 * 60 * 1000));
  // }
};
